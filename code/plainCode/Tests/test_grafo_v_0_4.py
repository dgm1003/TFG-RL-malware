import unittest
import networkx as nx
import matplotlib.pyplot as plt

import sys
sys.path.append("./code")

from plainCode.grafo_v_0_4 import GrafoRed

class test_grafo_v_0_4(unittest.TestCase):
    
    # Caso de prueba 1: generación de red
    #
    # comprobamos que se generan redes con el tamaño correcto y asignando propiedades del riesgo.
    def test_generar_red(self):
        #generamos una red de 10 nodos
        NNODOS = 10
        red = GrafoRed(NNODOS)
        self.assertEqual(red.grafo.number_of_nodes(), 10, "se ha generado la red con los nodos apropiados")

        #generamos la red sin nodos de riesgo
        red = GrafoRed(NNODOS, ratio_riesgo=0)
        for nodo in red.grafo.nodes(data=True):
            self.assertEqual(nodo[1]["riesgo"],1, "se le ha asignado riesgo cuando no debería")
        #generamos la red con todos nodos de riesgo
        red = GrafoRed(NNODOS, ratio_riesgo=1)
        for nodo in red.grafo.nodes(data=True):
            self.assertEqual(nodo[1]["riesgo"], 10, "no se le ha asignado riesgo cuando debería")
    
    # Caso de prueba 2: selección de nodos de riesgo
    #
    # comprobamos que se pueden modificar los nodos de alto riesgo correctamente.
    def test_define_alto_riesgo(self):
        #generamos una red simple
        NNODOS = 5
        red = GrafoRed(NNODOS)
        #asignamos dos nodos como de alto riesgo
        lista_riesgo = [2,4]
        red.define_alto_riesgo(lista_riesgo)
        #comprobamos que la asignación ha sido correcta
        for i in range(NNODOS):
            if i in lista_riesgo:
                self.assertEqual(red.grafo.nodes[i]["riesgo"], 10, "no se le ha asignado riesgo cuando debería")
            else:
                self.assertEqual(red.grafo.nodes[i]["riesgo"], 1, "se le ha asignado riesgo cuando no debería")

    # Caso de prueba 3: recompensas entre nodos conectados
    #
    # comprobamos que se obtiene correctamente la recompensa usando el método apropiado
    def test_obtener_recompensa_conexiones(self):
        #creamos una red simple
        NNODOS = 6
        red = GrafoRed(NNODOS, seed=1)
        # conexiones existentes: 0-1, 0-2, 0-3, 1-2, 1-3, 1-4, 2-3, 2-4, 4-5
        #comprobamos que dos de las conexiones existentes no tienen penalización máxima
        self.assertTrue(red.obtener_recompensa(0,1) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(1,0) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(1,2) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(2,1) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        #comprobamos que las conexiones inexistentes tienen una penalización mucho mayor
        self.assertEqual(red.obtener_recompensa(0,4), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(4,0), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(3,4), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(4,3), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")

        #comprobamos lo mismo suponiendo que están infectados los nodos
        #comprobamos que dos de las conexiones existentes no tienen penalización máxima
        self.assertTrue(red.obtener_recompensa(0+NNODOS,1) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(1+NNODOS,0) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(1+NNODOS,2) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(2+NNODOS,1) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        #comprobamos que las conexiones inexistentes tienen una penalización mucho mayor
        self.assertEqual(red.obtener_recompensa(0+NNODOS,4), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(4+NNODOS,0), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(3+NNODOS,4), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(4+NNODOS,3), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")

    # Caso de prueba 4: recompensas para nodos especiales
    #
    # Comprobamos que se guardan las características de valor y riesgo en la tabla de recompensas
    def test_obtener_recompensa_riesgo_valor(self):
        #creamos una red simple
        NNODOS = 6
        red = GrafoRed(NNODOS, seed=1)
        lista_riesgo = [0]
        red.define_alto_riesgo(lista_riesgo)
        # conexiones existentes: 0-1, 0-2, 0-3, 1-2, 1-3, 1-4, 2-3, 2-4, 4-5
        # nodos de poco valor: 6
        # nodos de alto riesgo: 0

        #comprobamos que se ha reflejado en las recompensas las características de los nodos
        self.assertEqual(red.obtener_recompensa(1,0), -10, "No se ha tenido en cuenta que el nodo 0 es de alto riesgo")
        self.assertEqual(red.obtener_recompensa(2,0), -10, "No se ha tenido en cuenta que el nodo 0 es de alto riesgo")
        self.assertEqual(red.obtener_recompensa(3,0), -10, "No se ha tenido en cuenta que el nodo 0 es de alto riesgo")
        self.assertEqual(red.obtener_recompensa(1+NNODOS,0), -10, "No se ha tenido en cuenta que el nodo 1 es de alto riesgo")
        self.assertEqual(red.obtener_recompensa(2+NNODOS,0), -10, "No se ha tenido en cuenta que el nodo 1 es de alto riesgo")
        self.assertEqual(red.obtener_recompensa(3+NNODOS,0), -10, "No se ha tenido en cuenta que el nodo 1 es de alto riesgo")

        self.assertEqual(red.obtener_recompensa(4,5), -3, "No se ha tenido en cuenta que el nodo 6 tiene poco valor")
        self.assertEqual(red.obtener_recompensa(4+NNODOS,5), -3, "No se ha tenido en cuenta que el nodo 6 tiene poco valor")

    # Caso de prueba 5: recompensas para infección
    #
    # Comprobamos que se asigna recompensas a la infección de los nodos de forma correcta
    def test_infeccion(self):
        #creamos una red simple
        NNODOS = 3
        meta = 0
        red = GrafoRed(NNODOS, meta, seed=1) #todos conectados con todos
        #comprobamos que al infectar nodos no objetivo, se penaliza
        self.assertTrue(red.obtener_recompensa(1,1+NNODOS) < 0, "Se ha tratado la infección de un nodo no objetivo como positiva cuando no lo es")
        self.assertTrue(red.obtener_recompensa(2,2+NNODOS) < 0, "Se ha tratado la infección de un nodo no objetivo como positiva cuando no lo es")
        #comprobamos que al infectar el nodo objetivo, se otorga una recompensa positiva
        self.assertTrue(red.obtener_recompensa(0,0+NNODOS) > 0, "Se ha tratado la infección del nodo objetivo como negativa cuando no lo es")

    # Caso de prueba 6: recompensas para mantenerse en el sitio
    #
    # Comprobamos que se asigna recompensas a no moverse de nodo de forma correcta
    def test_no_mover(self):
        #creamos una red simple
        NNODOS = 3
        meta = 0
        red = GrafoRed(NNODOS, meta, seed=1) #todos conectados con todos
        #comprobamos que hay una recompensa positiva al quedarse en el nodo objetivo 
        self.assertTrue(red.obtener_recompensa(0+NNODOS,0+NNODOS) > 0, "Se penaliza por no moverse del nodo objetivo cuando no debería ser así")
        #comprobamos que hay una recompensa negativa al quedarse estacionado en otros nodos
        self.assertEqual(red.obtener_recompensa(0,0), -1, "No se penaliza por quedarse quieto en un nodo no objetivo, y debería")
        self.assertEqual(red.obtener_recompensa(1,1), -1, "No se penaliza por quedarse quieto en un nodo no objetivo, y debería")
        self.assertEqual(red.obtener_recompensa(2,2), -1, "No se penaliza por quedarse quieto en un nodo no objetivo, y debería")
        self.assertEqual(red.obtener_recompensa(1+NNODOS,1+NNODOS), -1, "No se penaliza por quedarse quieto en un nodo no objetivo, y debería")
        self.assertEqual(red.obtener_recompensa(2+NNODOS,2+NNODOS), -1, "No se penaliza por quedarse quieto en un nodo no objetivo, y debería")
        #comprobamos que no se puede pasar de un nodo infectado a su versión no infectada
        self.assertEqual(red.obtener_recompensa(0+NNODOS,0), -111, "Se permite revertir la infección de un nodo, y no debería")
        self.assertEqual(red.obtener_recompensa(1+NNODOS,1), -111, "Se permite revertir la infección de un nodo, y no debería")
        self.assertEqual(red.obtener_recompensa(2+NNODOS,2), -111, "Se permite revertir la infección de un nodo, y no debería")
    
if __name__ == '__main__':
    unittest.main()