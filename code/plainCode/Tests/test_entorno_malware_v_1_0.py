import unittest

import sys
sys.path.append("./code")

from plainCode.entorno_malware_v_1_0 import Red

# Tests unitarios del archivo entorno_malware_v_1_0.py
#
# Author: Diego García Muñoz
# Tutores: Bruno Baruque Zanón y Roberto Carlos Casado Vara
# Trabajo Fin de Grado, Ingeniería Informática, Universidad de Burgos Curso 2022-2023
class test_entorno_malware_v_1_0(unittest.TestCase):
    
    # Caso de prueba 1: generación de red
    #
    # comprobamos que se generan redes con el tamaño correcto y asignando propiedades del riesgo.
    def test_generar_red(self):
        #generamos una red de 10 nodos
        NNODOS = 10
        inicial=7
        meta=0
        red = Red(NNODOS,inicial,meta, ratio_riesgo=0)
        # comprobamos que se ha configurado correctamente
        self.assertEqual(red.grafo.number_of_nodes(), 10, "no se ha generado la red con los nodos apropiados")
        self.assertEqual(red.inicial, inicial, "no se ha definido el nodo inicial correctamente")
        self.assertEqual(red.estado, inicial, "no se ha definido el estado inicial correctamente")
        self.assertEqual(red.meta, meta, "no se ha definido el nodo objetivo correctamente")

        # comprobamos que no tiene nodos de riesgo
        for nodo in red.grafo.nodes(data=True):
            self.assertEqual(nodo[1]["riesgo"],1, "se le ha asignado riesgo cuando no debería")

        #generamos la red con todos nodos de riesgo
        red = Red(NNODOS,inicial,meta, ratio_riesgo=1)
        for nodo in red.grafo.nodes(data=True):
            self.assertEqual(nodo[1]["riesgo"], 10, "no se le ha asignado riesgo cuando debería")
    
    # Caso de prueba 2: generación de redes predefinidas
    #
    # Comprobamos que se generan las redes predefinidas correctamente
    def test_genera_predefinido(self):
        # guardamos las características de cada red predefinida en varias listas:
        lista_predefinidos=[1,2,3,4]
        lista_NNODOS=[9,30,30,100]
        lista_metas=[5,15,15,65]
        lista_inicios=[7,17,17,66]
        lista_riesgos=[[6],[1,4,5,7,8],[0,1,4,5,8],None]

        # iteramos sobre las cuatro redes predefinidas comprobando sus características
        for (predefinido, NNODOS, meta, inicial, riesgos) in zip(lista_predefinidos,lista_NNODOS,lista_metas,lista_inicios,lista_riesgos):
            red = Red(predefinido=predefinido)
            self.assertEqual(red.grafo.number_of_nodes(), NNODOS, "no se ha generado la red "+str(predefinido)+" con los nodos apropiados")
            self.assertEqual(red.obtener_recompensa(meta,NNODOS), 999, "no se ha definido la meta de la red "+str(predefinido)+" correctamente")
            self.assertEqual(red.estado, inicial, "no se ha inicializado la red "+str(predefinido)+" en el estado correcto")
            if riesgos is not None:
                for e in riesgos:
                    self.assertEqual(red.grafo.nodes[e]["riesgo"], 10, "no se han asignado los riesgos de la red "+str(predefinido)+" correctamente")

    # Caso de prueba 3: recompensas entre nodos conectados
    #
    # comprobamos que se obtiene correctamente la recompensa usando el método apropiado
    def test_obtener_recompensa_conexiones(self):
        #creamos una red simple
        NNODOS = 6
        inicial=3
        meta=0
        red = Red(NNODOS, inicial, meta, seed=1)
        # conexiones existentes: 0-1, 0-2, 0-3, 1-2, 1-3, 1-4, 2-3, 2-4, 4-5
        #comprobamos que dos de las conexiones existentes no tienen penalización máxima
        self.assertTrue(red.obtener_recompensa(0,1) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(1,0) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(1,2) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        self.assertTrue(red.obtener_recompensa(2,1) > -111, "La recompensa de una conexión válida no se ha calculado correctamente")
        #comprobamos que las conexiones inexistentes tienen una penalización mucho mayor
        self.assertEqual(red.obtener_recompensa(0,4), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(4,0), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(3,4), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")
        self.assertEqual(red.obtener_recompensa(4,3), -111, "La recompensa de una conexión inválida no se ha calculado correctamente")

        #como en este caso que un nodo esté infectado o no es definido por una variable del nodo, no hay que comprobar más
        
    # Caso de prueba 4: recompensas para nodos especiales
    #
    # Comprobamos que se guardan las características de valor y riesgo en la tabla de recompensas
    def test_obtener_recompensa_riesgo_valor(self):
        #creamos una red simple
        NNODOS = 6
        inicial=3
        meta=0
        red = Red(NNODOS, inicial, meta, seed=1, ratio_riesgo=1)
        # conexiones existentes: 0-1, 0-2, 0-3, 1-2, 1-3, 1-4, 2-3, 2-4, 4-5
        # nodos de poco valor: 6
        # nodos de alto riesgo: Todos

        #comprobamos que se ha reflejado en las recompensas las características de los nodos
        self.assertEqual(red.obtener_recompensa(1,0), -10, "No se ha tenido en cuenta que el nodo destino es de alto riesgo")
        self.assertEqual(red.obtener_recompensa(2,0), -10, "No se ha tenido en cuenta que el nodo destino es de alto riesgo")
        self.assertEqual(red.obtener_recompensa(3,0), -10, "No se ha tenido en cuenta que el nodo destino es de alto riesgo")
        
        self.assertEqual(red.obtener_recompensa(4,5), -3, "No se ha tenido en cuenta que el nodo 6 tiene poco valor")
        
    # Caso de prueba 5: recompensas para infección
    #
    # Comprobamos que se asigna recompensas a la infección de los nodos de forma correcta
    def test_obtener_recompensa_infeccion(self):
        #creamos una red simple
        NNODOS = 3
        inicial=2
        meta=0
        red = Red(NNODOS, inicial, meta, seed=1) #todos conectados con todos
        #comprobamos que al infectar nodos no objetivo, se penaliza
        self.assertTrue(red.obtener_recompensa(1,NNODOS) < 0, "Se ha tratado la infección de un nodo no objetivo como positiva cuando no lo es")
        self.assertTrue(red.obtener_recompensa(2,NNODOS) < 0, "Se ha tratado la infección de un nodo no objetivo como positiva cuando no lo es")
        #comprobamos que al infectar el nodo objetivo, se otorga una recompensa positiva
        self.assertTrue(red.obtener_recompensa(0,NNODOS) > 0, "Se ha tratado la infección del nodo objetivo como negativa cuando no lo es")

    # Caso de prueba 6: recompensas para mantenerse en el sitio
    #
    # Comprobamos que se asigna recompensas a no moverse de nodo de forma correcta
    def test_obtener_recompensa_no_mover(self):
        #creamos una red simple
        NNODOS = 3
        inicial=0
        meta=0
        red = Red(NNODOS, inicial, meta, seed=1) #todos conectados con todos
        # comprobamos que hay una recompensa negativa al quedarse estacionado en
        # cualquier nodo que no sea el objetivo mientras está infectado
        self.assertEqual(red.obtener_recompensa(0,0), -1, "No se penaliza por quedarse quieto en un nodo no objetivo, y debería")
        self.assertEqual(red.obtener_recompensa(1,1), -1, "No se penaliza por quedarse quieto en un nodo no objetivo, y debería")
        self.assertEqual(red.obtener_recompensa(2,2), -1, "No se penaliza por quedarse quieto en un nodo no objetivo, y debería")
        
        # infectamos el nodo objetivo
        red.step(NNODOS)
        #comprobamos que hay una recompensa positiva al quedarse en el nodo objetivo 
        self.assertTrue(red.obtener_recompensa(0,0) > 0, "Se penaliza por no moverse del nodo objetivo cuando no debería ser así")
    
    # Caso de prueba 7: método de realizar acciones
    #
    # Comprobamos que se realizan las acciones de manera correcta
    def test_step(self):
        #creamos una red simple
        NNODOS = 3
        inicial=2
        meta=0
        red = Red(NNODOS, inicial, meta, seed=1, ratio_riesgo=0) #todos conectados con todos, ninguno de riesgo
        # comprobamos los atributos iniciales de los nodos
        self.assertEqual(red.grafo.nodes[inicial]['color'], 'blue', "no se ha definido correctamente el color del nodo inicial")
        self.assertEqual(red.grafo.nodes[meta]['color'], 'yellow', "no se ha definido correctamente el color del nodo meta")
        self.assertEqual(red.grafo.nodes[1]['color'], 'cyan', "no se ha definido correctamente el color del resto de nodos")
        self.assertEqual(red.grafo.edges[2, 0]['color'], 'black', "no se ha definido correctamente el color del camino")
        self.assertEqual(red.grafo.edges[2, 0]['grosor'], 1, "no se ha definido correctamente el grosor del camino")

        # nos movemos del nodo 2 al 0
        estado, recompensa, finalizado = red.step(0)
        # comprobamos el nuevo estado del entorno
        self.assertEqual(estado, 0, "no se ha movido al nodo correcto")
        self.assertEqual(recompensa, -1, "no se ha devuelto la recompensa apropiada")
        self.assertFalse(finalizado, "se ha dado por acabado sin llegar al objetivo")
        # comprobamos que se han actualizado los atributos
        self.assertEqual(red.grafo.edges[2, 0]['color'], 'red', "no se ha actualizado correctamente el color del camino")
        self.assertEqual(red.grafo.edges[2, 0]['grosor'], 3, "no se ha actualizado correctamente el grosor del camino")
        self.assertEqual(red.grafo.nodes[0]['color'], 'green', "no se ha actualizado correctamente el color de un nodo del camino")

        # infectamos el nodo 0
        estado, recompensa, finalizado = red.step(3)
        # comprobamos el nuevo estado del entorno
        self.assertEqual(estado, 0, "no se ha quedado en su sitio")
        self.assertEqual(recompensa, 999, "no se ha devuelto la recompensa apropiada")
        self.assertTrue(finalizado, "no se ha dado por acabado al llegar al objetivo")
        # comprobamos que se han actualizado los atributos
        self.assertEqual(red.grafo.nodes[0]['color'], 'red', "no se ha actualizado correctamente el color de un nodo del camino")

    
    # Caso de prueba 8: método de probar a realizar acciones
    #
    # Comprobamos que se puede probar la realización de acciones sin hacer cambios en el entorno
    def test_step_prueba(self):
        #creamos una red simple
        NNODOS = 3
        inicial=2
        meta=0
        red = Red(NNODOS, inicial, meta, seed=1, ratio_riesgo=0) #todos conectados con todos, ninguno de riesgo
        # comprobamos los atributos iniciales de los nodos
        self.assertEqual(red.grafo.nodes[inicial]['color'], 'blue', "no se ha definido correctamente el color del nodo inicial")
        self.assertEqual(red.grafo.nodes[meta]['color'], 'yellow', "no se ha definido correctamente el color del nodo meta")
        
        # probamos a movernos del nodo 1 al 0, siendo la posición real el nodo 2
        estado, recompensa = red.step_prueba(1,0)
        # comprobamos los valores devueltos
        self.assertEqual(estado, 0, "no se ha devuelto el número de nodo correcto")
        self.assertEqual(recompensa, -1, "no se ha devuelto la recompensa apropiada")
        # comprobamos que no se han modificado los atributos de la red
        self.assertNotEqual(estado, red.estado, "se ha actualizado el estado cuando no debería")
        self.assertEqual(red.grafo.nodes[inicial]['color'], 'blue', "el color del nodo inicial ha cambiado")
        self.assertEqual(red.grafo.nodes[meta]['color'], 'yellow', "el color del nodo meta ha cambiado")

    # Caso de prueba 9: obtener si un nodo está infectado
    #
    # Comprobamos que se detecta correctamente si un nodo está infectado o no
    def test_get_infectado(self):
        #creamos una red simple
        NNODOS = 3
        inicial=2
        meta=0
        red = Red(NNODOS, inicial, meta, seed=1) #todos conectados con todos

        # comprobamos que al inicio el nodo no está infectado
        self.assertFalse(red.get_infectado(inicial), "devuelve que un nodo está infectado cuando no es así")
        # lo infectamos, y comprobamos otra vez
        red.step(NNODOS)
        self.assertTrue(red.get_infectado(inicial), "devuelve que un nodo no está infectado cuando sí es así")
        # nos movemos a otro nodo y comprobamos que sigue infectado el primero
        red.step(1)
        self.assertTrue(red.get_infectado(inicial), "devuelve que un nodo no está infectado cuando sí es así")

    # Caso de prueba 10: reinicio del entorno
    #
    # Comprobamos que se reinicia el entorno correctamente
    def test_reset(self):
        #creamos una red simple
        NNODOS = 3
        inicial=2
        meta=0
        red = Red(NNODOS, inicial, meta, seed=1) #todos conectados con todos

        # infectamos el nodo inicial y nos movemos a otro
        red.step(NNODOS)
        red.step(1)
        # comprobamos que se han actualizado los atributos
        self.assertEqual(red.estado, 1, "no se ha movido al siguiente estado")
        self.assertTrue(red.get_infectado(2), "no se ha infectado el nodo deseado")
        self.assertEqual(red.grafo.edges[2, 1]['color'], 'red', "no se ha actualizado correctamente el color del camino")
        self.assertEqual(red.grafo.edges[2, 1]['grosor'], 3, "no se ha actualizado correctamente el grosor del camino")
        self.assertEqual(red.grafo.nodes[2]['color'], 'red', "no se ha actualizado correctamente el color de un nodo infectado")
        self.assertEqual(red.grafo.nodes[1]['color'], 'green', "no se ha actualizado correctamente el color de un nodo del camino")

        # reiniciamos el entorno
        red.reset()
        # comprobamos que los valores han vuelto a sus estados iniciales
        self.assertEqual(red.estado, 2, "no se ha reiniciado correctamente el estado")
        self.assertFalse(red.get_infectado(2), "no se ha reiniciado el estado de infección de los nodos")
        self.assertEqual(red.grafo.edges[2, 1]['color'], 'black', "no se ha reiniciado correctamente el color del camino")
        self.assertEqual(red.grafo.edges[2, 1]['grosor'], 1, "no se ha reiniciado correctamente el grosor del camino")
        self.assertEqual(red.grafo.nodes[2]['color'], 'blue', "no se ha reiniciado correctamente el color de un nodo infectado")
        self.assertEqual(red.grafo.nodes[1]['color'], 'cyan', "no se ha reiniciado correctamente el color de un nodo del camino")

    # el método render() se probará manualmente

if __name__ == '__main__':
    unittest.main()