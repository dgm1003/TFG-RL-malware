import json
import random
import matplotlib.pyplot as plt
import networkx as nx


# Clase que representa el entorno. Tendrá una representación de una red de
# ordenadores, creada mediante NetworkX, además de la situación del agente malware.
# Cuenta con funciones que permiten indicar acciones al malware, y obtener 
# información sobre el nuevo estado, además de poder reiniciar el entorno y 
# obtener visualizaciones gráficas.
#
# Adaptado al uso en la página web
#  
# Author: Diego García Muñoz
# Tutores: Bruno Baruque Zanón y Roberto Carlos Casado Vara
# Trabajo Fin de Grado, Ingeniería Informática, Universidad de Burgos Curso 2022-2023
class Red():

    # constructor de la clase, genera una red de ordenadores de forma 
    # aleatoria e inicializa el malware en el estado inicial
    # 
    # Parámetros:
    #  - NNODOS: el número de nodos de la red
    #  - inicial: el número del nodo inicial
    #  - meta: el número del nodo objetivo
    #  - seed: la semilla para la generación aleatoria
    #  - ratio_riesgo: el porcentaje de nodos que se considerarán de alto riesgo
    #  - predefinido: indica si se desea utilizar un grafo predefinido, y cual
    #  - jsonSource: archivo JSON del cual extraer los datos del entorno 
    def __init__(self, NNODOS=30, inicial=None, meta=None, seed=None, ratio_riesgo=0.25, predefinido=0, jsonSource=None):
        
        #si se ha proporcionado un archivo JSON, se utiliza
        if jsonSource is not None:
            # inicializamos la red con los datos JSON
            self.from_json(jsonSource)

        else:

            if predefinido > 0 and predefinido < 6:
                self.genera_predefinido(predefinido)
            else:
                # guardamos el número de nodos 
                self.NNODOS = NNODOS
                # generamos el grafo
                self.genera_red(seed=seed, ratio_riesgo=ratio_riesgo)

                #definimos el estado inicial (lo guardamos aparte también para poder resetear el entorno) y la meta
                self.inicial = inicial
                self.estado = inicial
                self.meta = meta

            # guardamos si están infectados o no los nodos (empiezan todos sin infectar), y
            # el color y grosor de los nodos y conexiones en el renderizado. 
            nx.set_node_attributes(self.grafo, False, "infectado")
            nx.set_edge_attributes(self.grafo, 'dimgrey', 'color')
            nx.set_edge_attributes(self.grafo, 1, 'grosor')
            
            if self.inicial is not None and self.meta is not None:
                # se seleccionan colores diferentes para los nodos de inicio y fin
                self.grafo.nodes[self.meta]['color'] = 'yellow'
                self.grafo.nodes[self.inicial]['color'] = 'blue'

            # definimos un tiempo límite para llegar al objetivo
            self.tiempo_limite = self.NNODOS*2
    
    def genera_red(self, seed=None, conexiones=None, lista_riesgo=None, ratio_riesgo=0.25):
        # si se incluye una lista de conexiones del grafo, se utiliza
        if conexiones is not None:
            self.grafo.add_edges_from(conexiones)
        # si no, se genera mediante networkX
        else:
            self.grafo = nx.random_internet_as_graph(self.NNODOS, seed=seed)
        
        # si se incluye una lista de nodos de riesgo, se asignan esos nodos
        if lista_riesgo is not None:
            # Reiniciamos los riesgos de los nodos
            nx.set_node_attributes(self.grafo, 1, "riesgo")
            nx.set_node_attributes(self.grafo, 'cyan', "color")

            # Asignamos los nuevos riesgos
            for i in lista_riesgo:
                self.grafo.nodes[i]["riesgo"] = 10
                self.grafo.nodes[i]["color"] = "orange"
                
            dict_col = nx.get_node_attributes(self.grafo, "color")
            self.dict_colores = {key:{'color':value} for key,value in dict_col.items()}

        # si no, se asignan basándose en el ratio y la semilla
        else:
            dict_riesgos = {}
            dict_colores = {}
            
            # seleccionamos al azar un porcentaje de los nodos como nodos de alto riesgo
            random.seed(seed)
            for i in range(self.NNODOS):
                if random.random() < ratio_riesgo:
                    dict_riesgos[i] = {"riesgo" : 10}
                    dict_colores[i] = {"color" : "orange"}
                else:
                    dict_riesgos[i] = {"riesgo" : 1}
                    dict_colores[i] = {"color" : "cyan"}
            # guardamos los riesgos de los nodos
            nx.set_node_attributes(self.grafo, dict_riesgos)
            nx.set_node_attributes(self.grafo, dict_colores)
            # guardamos los datos de los nodos de riesgo para poder reiniciar la red
            self.dict_colores = dict_colores



    
    # Crea una red ya predefinida anteriormente. Se cuenta con cuatro redes:
    #   - Una con 9 nodos
    #   - Otra con 30 nodos y ningún nodo de riesgo en el camino más corto
    #   - Otra con 30 nodos y nodos de riesgo en el camino más corto
    #   - Una con 190 nodos
    #   - Una última con 3000 nodos
    # 
    # Parámetros:
    #   - Predefinido: identificador de la red que se quiere generar
    def genera_predefinido(self, predefinido):
        self.grafo = nx.Graph()

        if predefinido == 1:
            self.NNODOS = 9
            self.meta=5
            self.inicial=7
            self.estado=7
            conexiones = [(0,1), (1,2), (1,3), (2,4), (2,5), (3,6), (3,7), (3,8)]
            self.genera_red(conexiones=conexiones, lista_riesgo=[6])
        
        elif predefinido == 2:
            self.NNODOS=30
            self.meta=15
            self.inicial=17
            self.estado=17
            self.genera_red(seed=123456, lista_riesgo=[1,4,5,7,8])
            
        elif predefinido == 3:
            self.NNODOS=30
            self.meta=15
            self.inicial=17
            self.estado=17
            self.genera_red(seed=123456, lista_riesgo=[0,1,4,5,8])
            
        elif predefinido == 4:
            self.NNODOS=150
            self.meta=77
            self.inicial=143
            self.estado=143
            self.genera_red(seed=12345678, ratio_riesgo=0.25)
    
        elif predefinido == 5:
            self.NNODOS=3000
            self.meta=1668
            self.inicial=2207
            self.estado=2207
            self.genera_red(seed=12345678, ratio_riesgo=0.25)

    
    # Método que define el inicio y la meta de la red
    # 
    # Parámetros:
    #   - inicial: el nuevo nodo inicial
    #   - meta: el nuevo nodo objetivo 
    def define_inicio_meta(self, inicial, meta):
        
        # si ya había un inicio y meta definidos, se resetean sus colores
        if self.inicial is not None:
            self.grafo.nodes[self.inicial]['color'] = 'cyan'
        if self.meta is not None:
            self.grafo.nodes[self.meta]['color'] = 'cyan'

        self.inicial = inicial
        self.estado = inicial
        self.meta = meta
        # se seleccionan colores diferentes para los nodos de inicio y fin
        self.grafo.nodes[self.meta]['color'] = 'yellow'
        self.grafo.nodes[self.inicial]['color'] = 'blue'
        
    # Método que define los nodos de riesgo de la red
    # 
    # Parámetros:
    #   - lista_riesgo: los nuevos nodos de riesgo
    def define_nodos_riesgo(self, lista_riesgo):
        
        # se reinicia los colores y riesgos de todos los nodos
        nx.set_node_attributes(self.grafo, 'cyan', "color")
        nx.set_node_attributes(self.grafo, 1, "riesgo")
        # Asignamos los nuevos riesgos
        for i in lista_riesgo:
            self.grafo.nodes[i]["riesgo"] = 10
            self.grafo.nodes[i]["color"] = "orange"

        # se seleccionan colores diferentes para los nodos de inicio y fin
        self.grafo.nodes[self.meta]['color'] = 'yellow'
        self.grafo.nodes[self.inicial]['color'] = 'blue'

        dict_col = nx.get_node_attributes(self.grafo, "color")
        self.dict_colores = {key:{'color':value} for key,value in dict_col.items()}
        
    # método que se ejecuta cada vez que se aplica una acción.
    # 
    # Parámetros:
    #   - acción: la acción que se desea realizar
    # Return:
    #   - estado: el nuevo estado del entorno
    #   - recompensa: el valor de la recompensa asociada a la acción realizada
    #   - finalizado: valor booleano que indica si la simulación ha finalizado 
    def step(self, accion):

        # Pasa 1 segundo en el reloj
        self.tiempo_limite -= 1 
        
        # Calculamos la recompensa
        recompensa = self.obtener_recompensa(self.estado, accion)
        
        # si la acción es infectar (la definimos como NNODOS, es decir, un número que no corresponde 
        # a un nodo), infectamos. También actualizamos el color del nodo para que lo refleje
        if accion == self.NNODOS:
            self.grafo.nodes[self.estado]['infectado'] = True
            self.grafo.nodes[self.estado]['color'] = 'red'
        # si no, omprobamos que existe la conexión y cambiamos el estado
        # además de los colores de la conexión por la que ha viajado y el nodo que ha visitado
        elif self.grafo.has_edge(self.estado, accion):
            self.grafo.edges[self.estado, accion]['color'] = 'red'
            self.grafo.edges[self.estado, accion]['grosor'] = 3
            self.estado = accion
            self.grafo.nodes[self.estado]['color'] = 'green'
        
        # Comprobamos que no se haya llegado al final del episodio
        if ( self.tiempo_limite <= 0 or
            (self.estado == self.meta and self.grafo.nodes[self.estado]['infectado']) ): 
            finalizado = True
        else:
            finalizado = False
        
        # Devolvemos los datos
        return self.estado, recompensa, finalizado,
    
    # Método que obtiene la recompensa de una acción
    # 
    # Parámetros:
    #  - actual: estado actual
    #  - siguiente: acción a realizar (número de nodo a moverse o NNODOS para infectar)
    # Return: la recompensa de dicha acción partiendo de dicho estado
    def obtener_recompensa(self, actual, siguiente):

        recompensa = -111
        # si se está infectando al nodo actual
        if(siguiente == self.NNODOS):
            # si el nodo actual es el objetivo, devuelve la máxima recompensa
            if(actual == self.meta):
                recompensa = 999
            else:
            # en caso contrario, penaliza la acción
                recompensa = -5

        # si se mantiene en el estado actual
        elif(actual == siguiente):
            # si está en el estado objetivo, devuelve la máxima recompensa
            if(actual == self.meta and self.grafo.nodes[actual]['infectado']):
                recompensa = 999
            else:
            # en caso contrario, penalización de -1 al haber pasado el tiempo
                recompensa = -1
        
        # si se mueve por una conexión válida
        elif( self.grafo.has_edge(actual, siguiente) ):
            # si el destino aporta poca información, se penaliza ligeramente
            if(self.grafo.degree(siguiente)==1):
                recompensa = -3
            else:
            # en caso contrario, devolvemos el riesgo del nodo (el riesgo mínimo 
            # será 1, equivalente a la penalización por tiempo)
                recompensa = - self.grafo.nodes[siguiente]["riesgo"]

        # si no es ninguno de los casos anteriores, penalización máxima al ser un movimiento imposible.
        return recompensa
    
    # Método que obtiene los estados a los que se puede llegar desde el estado actual
    # 
    # Parámetros:
    #  - actual: el estado actual
    # Return:
    #  - acciones: las acciones posibles desde ese estado
    def get_posibles_acciones(self, actual):

        # incluimos los nodos a los que puede llegar desde el actual
        acciones = [a for a in self.grafo[actual]]
        # si es un estado no infectado, añadimos la acción de infectarlo
        if not self.grafo.nodes[actual]['infectado']: acciones.append(self.NNODOS)

        return acciones

    # Método que muestra una representación gráfica del entorno
    #
    # Leyenda:
    #   Conexiones:
    #    - negro: no recorrida
    #    - verde: recorrida
    #   Nodos:
    #    - azul claro: no visitado
    #    - azul oscuro: nodo de inicio
    #    - amarillo: nodo objetivo
    #    - verde: nodo visitado
    #    - rojo: nodo infectado
    # 
    # Parámetros:
    #   - saveAs: indica si se desea guardar el resultado como imagen,
    #       con uno de los nombres proporcionados
    #   - ruta: si se le proporciona una ruta por varios nodos, la resaltará por encima de los demás 
    def render(self, saveAs=0, ruta=None):

        plt.clf()
        # obtenemos los colores y grosores de los nodos y conexiones
        mapa_colores_nodos = nx.get_node_attributes(self.grafo,'color').values()
        mapa_colores_caminos = nx.get_edge_attributes(self.grafo,'color').values()
        mapa_grosores_caminos = list(nx.get_edge_attributes(self.grafo,'grosor').values())

        # seleccionamos una layout para la impresión
        pos = nx.spring_layout(self.grafo)
        # dibujamos los nodos y conexiones
        nx.draw_networkx_nodes(self.grafo,pos, node_color=mapa_colores_nodos, node_size=60)
        nx.draw_networkx_edges(self.grafo,pos, edge_color=mapa_colores_caminos, width=mapa_grosores_caminos)
        nx.draw_networkx_labels(self.grafo,pos, font_size=8)

        if ruta is not None:
            # dibujamos los nodos importantes por encima del resto
            H = self.grafo.subgraph(ruta)
            minimapa_colores_nodos = nx.get_node_attributes(H,'color').values()
            nx.draw_networkx_nodes(H,pos, node_color=minimapa_colores_nodos, node_size=100)
        elif self.inicial is not None and self.meta is not None:
            # dibujamos los nodos importantes por encima del resto
            H = self.grafo.subgraph([self.inicial, self.meta])
            minimapa_colores_nodos = nx.get_node_attributes(H,'color').values()
            nx.draw_networkx_nodes(H,pos, node_color=minimapa_colores_nodos, node_size=100)

        if saveAs == 0:
            plt.show()
        elif saveAs == -1:
            plt.savefig(fname="./code/website/websiteCode/frontendContents/static/images/test.png", format="png")
        elif saveAs == 1:
            plt.savefig(fname="./frontendContents/static/images/grafo_inicial.png", dpi=300, format="png")
        elif saveAs == 2:
            plt.savefig(fname="./frontendContents/static/images/grafo_camino.png", dpi=300, format="png")
    
    
    
    # Método que reinicia el entorno a su situación inicial
    #
    # Return: el estado inicial 
    def reset(self):
        # Reiniciamos las variables a sus valores iniciales
        self.estado = self.inicial
        # reiniciamos los atributos de los nodos y conexiones
        nx.set_node_attributes(self.grafo, False, "infectado")
        nx.set_node_attributes(self.grafo, self.dict_colores)
        nx.set_edge_attributes(self.grafo, 'dimgrey', 'color')
        nx.set_edge_attributes(self.grafo, 1, 'grosor')
        self.grafo.nodes[self.meta]['color'] = 'yellow'
        self.grafo.nodes[self.inicial]['color'] = 'blue'

        self.tiempo_limite = self.NNODOS*2
        return self.estado
    
    # Método que convierte el entorno a un objeto JSON
    # 
    # Return: una JSON string con los datos del entorno 
    def to_json(self):
        
        redJson = {}
        #NNODOS
        redJson["nnodos"] = str(self.NNODOS)
        #inicial
        redJson["inicial"] = str(self.inicial)
        #meta
        redJson["meta"] = str(self.meta)
        #estado
        redJson["estado"] = str(self.estado)
        #tiempo_limite
        redJson["tiempo_limite"] = str(self.tiempo_limite)
        #GRAFO
        redJson["grafo"] = nx.node_link_data(self.grafo)

        redJson['dict_colores'] = json.dumps(self.dict_colores)
        
        return json.dumps(redJson)

    # Método que, dada una string JSON, configura el entorno con esos datos.
    # 
    # Parámetros:
    #   - datosJson: los datos del entorno en formato JSON 
    def from_json(self, datosJson):

        redJson = json.loads(datosJson)
        self.NNODOS = int(redJson["nnodos"])
        self.tiempo_limite = int(redJson["tiempo_limite"])
        self.grafo = nx.node_link_graph(redJson["grafo"])
        
        dict_col = json.loads(redJson['dict_colores'])
        self.dict_colores = {int(key):value for key,value in dict_col.items()}

        if redJson['inicial'] == 'None':
            self.inicial = None
        else:
            self.inicial = int(redJson["inicial"])
        if redJson['meta'] == 'None':
            self.meta = None
        else:
            self.meta = int(redJson["meta"])
        if redJson['estado'] == 'None':
            self.estado = None
        else:
            self.estado = int(redJson["estado"])