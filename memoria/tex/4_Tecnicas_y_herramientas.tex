\capitulo{4}{Técnicas y herramientas}

En el siguiente capítulo se presentan las diferentes metodologías empleadas en la realización del proyecto, además de todas las herramientas de las que se ha hecho uso. Se habla también de las posibles alternativas que fueron consideradas, y las razones por las cuales se optó por una alternativa en vez de las demás.

\section{Metodologías de trabajo}

\subsection{Metodología ágil: Scrum}

Para la realización del Trabajo Fin de Grado se ha optado por tomar como base las metodologías ágiles, principalmente Scrum\cite{Scrum}, en vez de utilizar otras más tradicionales como la metodología Waterfall. 

La principal característica de la metodología Scrum es que el trabajo se realiza de manera iterativa e incremental, de modo que al final de cada iteración (también llamadas Sprints) se obtenga una versión del producto funcional, con un mayor número de características que en la iteración anterior. Para ello, los requisitos se dividen en tareas, se priorizan, y se van ordenando en el denominado Product Backlog. Al inicio de cada sprint se seleccionarán los requisitos que se ha decidido trabajar en dicho sprint, y se añadirán al Sprint Backlog. En Scrum se definen varios roles, siendo los más importantes el Product Owner, que se comunica con el cliente o usuario final para definir los requisitos y el backlog, y el Scrum Master, que se encargará del seguimiento y coordinación del modelo Scrum, además de solucionar aquellos problemas que tenga el equipo de desarrollo. Por último, para asegurar el avance fluido de los proyectos, se realizan varios tipos de reuniones: Una al inicio de un sprint, definiendo sus objetivos, reuniones diarias de seguimiento, y una al finalizar cada sprint, para evaluar el trabajo realizado en la iteración.

Para este trabajo se ha seguido una idea similar, realizando Sprints de 1-2 semanas, pero con varias modificaciones:

\begin{itemize}
    \item Los primeros sprints fueron destinados a adquirir conocimientos necesarios para la realización del trabajo, y por lo tanto, no resultaron en un producto funcional al finalizar dichos sprints.
    \item Debido al reducido número de personas que participan en el trabajo, no se ha realizado una división en roles, sino que es el alumno quien se encarga de todas las responsabilidades de cada rol, con asistencia de los tutores, en ocasiones actuando de Product Owner.
    \item Se han descartado las reuniones diarias, debido a que no sería posible coordinar el tiempo necesario entre el alumno y los tutores cada día. En vez de eso, el alumno trabajó por su cuenta, contactando con los tutores mediante correo electrónico en caso de que surgiese algún problema que bloquease el trabajo, o, en casos excepcionales, realizando reuniones extraordinarias.
    \item Las reuniones inicial y final de cada sprint se fusionaron, por la misma razón que el punto anterior, de modo que solamente se realizaba una reunión conjunta en la que se finalizaba un sprint y se planificaba el siguiente.
\end{itemize}

Se decidió abarcar el proyecto con esta metodología frente a otras tradicionales como la metodología en cascada porque ofrecía una mayor flexibilidad, priorizando la obtención de un programa funcional de manera rápida sin sacrificar calidad, y permitiendo su ampliación y modificación de forma fluida a lo largo del tiempo, dos puntos que se consideraron importantes para la realización de un Trabajo Fin de Grado

\subsection{Gestión del repositorio: GitHub con ZenHub}

Por otro lado, para realizar un seguimiento del proyecto por parte del alumno y de los profesores a la vez, y para tener los archivos y sus versiones accesibles fácilmente en internet, se decidió utilizar una página de control de versiones y repositorios. Se consideraron diferentes alternativas, como GitLab, CodeCommit, SourceForge o BitBucket; pero finalmente se decidió optar por \textbf{GitHub}\cite{Github}.

Como el propósito del repositorio era ser público, se descartaron opciones como GitLab, CodeCommit o BitBucket, que, aunque ofrezcan un mayor número de características, son más indicadas para repositorios privados.

GitHub, sin embargo, está centrada en repositorios públicos, y al ser una página muy popular cuenta con una gran cantidad de extensiones y aplicaciones que aportan muchas herramientas y opciones adicionales. Además, el alumno ya se ha familiarizado con el uso de dicha página durante el curso académico,

Por otro lado, para poder implementar la metodología Scrum, los issues y milestones de GitHub eran un buen primer paso, pero no ofrecían todas las opciones necesarias para ello. Por eso, como adición a GitHub, se decidió utilizar la extensión \textbf{ZenHub}\cite{Zenhub}, que permite un mejor control del proceso de integración contínua y gestión de proyecto Scrum.

\imagen{zenhub}{Ejemplo de control de issues y seguimiento Scrum con ZenHub}

\subsection{Control de calidad: Codacy, CodeClimate}
Para poder controlar la calidad del código que se va creando, existe una gran cantidad de aplicaciones compatibles con GitHub que analizan los archivos de los repositorios indicados, buscando diferentes tipos de problemas o malas prácticas. A menor número de estos problemas, el código será más fácil de comprender, mantener y utilizar, por lo que su calidad será mayor. 

Se ha optado por utilizar dos de estas aplicaciones: \textbf{Codacy}\cite{Codacy} y \textbf{CodeClimate Quality}.\cite{CodeClimate} Codacy detecta un mayor número de problemas que CodeClimate, y es capaz de analizar una mayor variedad de tipos de archivo, como CSS, pero existen problemas como la complejidad cognitiva (dificultad de comprensión del código) que solo se muestran en CodeClimate, por lo que se consideraron relevantes los análisis de ambas aplicaciones.

\section{Herramientas}
A continuación se muestran las herramientas utilizadas durante el desarrollo.

\subsection{Lenguaje de programación: Python}

El proyecto se propuso inicialmente con la intención de desarrollarse en \textbf{Python}\cite{Python}, debido a que existían librerías muy apropiadas para los objetivos definidos, e incluso para líneas de trabajo futuras como la inclusión de aprendizaje profundo por refuerzo. Las librerías utilizadas fueron las siguientes:

\begin{itemize}
    \item \textbf{Random:}\cite{Random} librería simple para la generación de secuencias de números aleatorios
    \item \textbf{Numpy:}\cite{Numpy} librería enfocada a trabajos matemáticos y con matrices. En nuestro caso, para que el algoritmo seleccionado resultase efectivo era necesario el uso de tablas, y esta librería facilitaba mucho la creación de dichas tablas y la búsqueda dentro de ellas.
    \item \textbf{Matplotlib:}\cite{Matplotlib} librería para la generación de elementos gráficos. Se utilizó para crear imágenes representativas de la red de ordenadores, facilitando la comprensión de dichas redes y su situación en cada momento.
    \item \textbf{NetworkX:}\cite{NetworkX} librería para la creación y el manejo de grafos. Las redes de ordenadores se tenían que estructurar y guardar de algún modo, y esta librería era ideal para ello. Además, ofrecía una gran cantidad de opciones para guardar diferentes atributos en los nodos y conexiones, agilizando la ejecución del algoritmo y simplificando la generación de imágenes con Matplotlib. También incluía herramientas para la  generación de redes de forma aleatoria, reduciendo mucho el tiempo de desarrollo.
    \item \textbf{Flask (incluye Jinja2):}\cite{Flask} framework para la creación de aplicaciones web. Fue indispensable para el desarrollo del sitio web.
    \item \textbf{Unittest:}\cite{Unittest} framework de automatización de pruebas, utilizado en la creación de pruebas unitarias.
\end{itemize}

Además de Python, también se tuvieron que usar otros lenguajes de programación. HTML y CSS fueron necesarios para el sitio web, y como también se utilizó \textbf{Docker}\cite{Docker} para empaquetar el programa en una imagen fácil de ejecutar, se tuvo que utilizar su lenguaje propio para los archivos de configuración de la imagen.

\subsection{IDE: Visual Studio Code}

Teniendo en cuenta que el proyecto se va a realizar con el lenguaje de programación Python, las IDEs consideradas fueron:
\begin{itemize}
    \item Spyder
    \item Visual Studio Code
    \item Jupyter Notebook
    \item Eclipse + PyDev
\end{itemize}

Se optó por \textbf{Visual Studio Code}\cite{VSC} por varias razones:
\begin{enumerate}
    \item No requiere de la instalación ni manejo de extensiones adicionales para el trabajo básico con Python, al contrario que Eclipse, aunque cuenta con una gran variedad de extensiones con funciones adicionales.
    \item Se trabaja con ficheros .py, en vez de .ipynb como en Jupyter, lo cual facilitará su uso en una página web en caso de que se decida desarrollar una, al no tener que exportar el código con cada modificación. Aún así, es compatible con ficheros .ipynb en caso de ser necesario trabajar con ellos.
    \item Cuenta con integración con Git, lo cual permite realizar commits de forma rápida y sencilla. Aunque Spyder también cuenta con funcionalidades similares, están menos desarrolladas y son más difíciles de usar, lo cual conllevaría un aumento del tiempo necesario para hacer commits u operaciones de push/pull.
\end{enumerate}

Sin embargo, en ocasiones se utilizó \textbf{Jupyter Notebook}\cite{Jupyter} y \textbf{Google Colab}\cite{Colab} para la realización de algunos tutoriales, además de \textbf{Spyder}\cite{Spyder} durante el estudio de valores óptimos, pues permitía un manejo más fácil de las gráficas de Matplotlib.

\subsection{Documentación: Overleaf}

Los programas que se consideraron fueron:
\begin{itemize}
    \item Microsoft Word
    \item OpenOffice Writer
    \item Overleaf
    \item Texmaker
\end{itemize}

Por un lado, se decidió utilizar el lenguaje \textbf{LaTeX}\cite{Latex}, pues es un lenguaje ofrece una gran cantidad de opciones para textos académicos, permitiendo el manejo fácil de aspectos como referencias, fórmulas matemáticas, o índices, aligerando la carga de trabajo en esos aspectos, y permitiendo al alumno centrarse en escribir la documentación en sí.

Dentro de los programas de edición de documentos LaTeX, el alumno se decantó por \textbf{Overleaf}\cite{Overleaf}, pues aunque es posible que ofrezca menos opciones que otros editores que se instalen en un ordenador, permite la edición colaborativa de documentos, lo cual es útil a la hora de mostrar el progreso realizado a los profesores y facilitarles el proceso de corrección.
